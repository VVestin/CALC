;.module FreeIntArg0
; Puts the integer at one below the top of the stack into IntArg0 and then frees it
FreeIntArg0:
pop bc
pop de
pop hl ; hl is the int to free
push de
push bc
push hl
ld de,IntArg0
ld b,3
_FreeIntArg0Loop:
ld a,(hl)
ld (de),a
inc hl
inc de
djnz _FreeIntArg0Loop
call FreeInt
ret

;.module FreeIntArg1
; Puts the integer at one below the top of the stack into IntArg1 and then frees it
FreeIntArg1:
pop bc
pop de
pop hl ; hl is the int to free
push de
push bc
push hl
ld de,IntArg1
ld b,3
_FreeIntArg1Loop:
ld a,(hl)
ld (de),a
inc hl
inc de
djnz _FreeIntArg1Loop
call FreeInt
ret

;.module If
; Checks the value on top of the stack, if it is false jumps to hl
If:
pop bc
pop de
push bc
ld b,3
_IfCheckLoop:
ld a,(de)
or a
ret nz
djnz _IfCheckLoop
pop bc
jp (hl) 


;.module PushIntLiteral
; Pushes the number in a (lsb) and de (msb) 
PushIntLiteral:
push de
push af
call AllocInt
pop hl
pop af
pop de
ld (hl),a
inc hl
ld (hl),d
inc hl
ld (hl),e
pop de
dec hl
dec hl
push hl
ex de,hl
jp (hl)

;.module StoIntVar
; Takes 3 bytes from the number at the top of the stack and moves them to de
StoIntVar:
pop bc
pop hl
push bc
ld b,0
ld c,3
ldir
ret

;.module Negate
; Negates the 3 byte integer at the top of the stack
Negate:
pop hl
push hl
ld a,(hl)
ld b,3
scf
ccf
_NegateCPLLoop:
ld a,0
sbc a,(hl)
ld (hl),a
inc hl
djnz _NegateCPLLoop
ret

;.module AbsValue
; If the number at the top of the stack is negative it is negated.
AbsValue:
pop hl
pop de
push de
inc de
inc de
ld a,(de)
bit 7,a
jr z,_AbsValueSkipNegate
call Negate
_AbsValueSkipNegate:
jp (hl)

;.module Compare
; Compares two numbers at the top of the stack
; Does a greater than if carry is set, otherwise a less than
Compare:
pop bc
pop hl
pop de
push bc
jr c, _CompareGreater
ex de,hl
_CompareGreater:
ld b,3
_CompareLoop:
ld a,(de)
cp (hl)
jr c,_CompareTrue
jr nz,_CompareFalse
djnz _CompareLoop
_CompareFalse:
ld b,0
jp _EqualsPushResult
_CompareTrue:
ld b,1
jp _EqualsPushResult

; .module CompareEqual (<= and >=)
; Compares two numbers at the top of the stack
; Does a greater than if carry is set, otherwise a less than
CompareEqual:
pop bc
pop hl
pop de
push bc
jr c, _CompareEqualGreater
ex de,hl
_CompareEqualGreater:
ld b,3
_CompareEqualLoop:
ld a,(de)
cp (hl)
jr c,_CompareEqualTrue
jr nz,_CompareEqualFalse
djnz _CompareEqualLoop
_CompareEqualTrue:
ld b,1
jp _EqualsPushResult
_CompareEqualFalse:
ld b,0
jp _EqualsPushResult

;.module Or
; Looks at two numbes on top of the stack. Pushes on a 1 if either is nonzero, otherwise a 0.
Or:
pop bc
pop hl
pop de
push bc
ld b,3
_OrLoop:
ld a,(de)
or a
jr nz, _OrTrue
ld a,(hl)
or a
jr nz, _OrTrue
inc hl
inc de
djnz _OrLoop
ld b,0
jr _EqualsPushResult
_OrTrue:
ld b,1
jr _EqualsPushResult

;.module And
; Looks at two numbers on top of the stack. Pushes on a 1 if both are nonzero, otherwise a 0.
And:
pop bc
pop hl
pop de
push bc
ld b,3
_AndLoop1:
ld a,(de)
or a
jr nz,_AndPartTrue
inc de
djnz _AndLoop1
ld b,0
jr _EqualsPushResult
_AndPartTrue:
ld b,3
_AndLoop2:
ld a,(hl)
or a
jr nz,_AndTrue
inc hl
djnz _AndLoop2
ld b,0
jr _EqualsPushResult
_AndTrue:
ld b,1
jr _EqualsPushResult

;.module Not
; Looks at number at the top of the stack. pushes a 0 if nonzero and 1 if 0
Not:
pop bc
pop hl
push bc
ld b,3
_NotLoop:
ld a,(hl)
or a
jr nz,_NotTrue
inc hl
djnz _NotLoop
ld b,1
jr _EqualsPushResult
_NotTrue:
ld b,0
jr _EqualsPushResult

;.module Equals
; Compares two numbers at the top of the stack for equality, leaving the stack with a 1 if equal
Equals:
pop bc
pop hl
pop de
push bc
ld b,3
_EqualsLoop:
ld a,(de)
cp (hl)
jr nz,_EqualsNotEqual
inc hl
inc de
djnz _EqualsLoop
ld b,1
jr _EqualsPushResult
_EqualsNotEqual:
ld b,0
_EqualsPushResult:
ld hl,(TempPtr)
ld (hl),b
ld b,2
_EqualsPushZeroes:
inc hl
ld (hl),0
djnz _EqualsPushZeroes
inc hl
ld (TempPtr),hl
dec hl
dec hl
dec hl
pop de
ex de,hl
push de
jp (hl)

;.module Mult
; Multiplies the two numbers at the top of the stack and leaves the stack with only the result
Mult:
ld b,3
ld hl,_MultResult
_MultClearResultLoop:
ld (hl),0
inc hl
djnz _MultClearResultLoop
pop bc
pop hl
pop de
push bc
ld b,24
_MultLoop:
push bc
ld b,2
ex de,hl
inc hl
inc hl
srl (hl)
_MultShiftDELoop:
dec hl
rr (hl)
djnz _MultShiftDELoop
ex de,hl
jr nc,_MultSkipAdd
push de
ld de,_MultResult
ld b,3
ccf ; Resets carry because carry should always be true here
_MultAddLoop:
ld a,(de)
adc a,(hl)
ld (de),a
inc hl
inc de
djnz _MultAddLoop
dec hl
dec hl
dec hl
pop de
_MultSkipAdd:
ld b,2
sla (hl)
_MultShiftHLLoop:
inc hl
rl (hl)
djnz _MultShiftHLLoop
dec hl
dec hl
pop bc
djnz _MultLoop
; Store the value in _MultResult in temp and push to stack 
ld hl,_MultResult
ld de,(TempPtr)
ld b,3
_MultPushLoop:
ld a,(hl)
ld (de),a
inc hl
inc de
djnz _MultPushLoop
dec de
dec de
dec de
pop hl
push de
push hl
ld de,(TempPtr)
ld h,0
ld l,3
add hl,de
ld (TempPtr),hl
ret
_MultResult:
.db $00, $00, $00, $00, $00, $00

;.module Add			; ORG IDE does not recognize .module directive :(
; Adds the two numbers at the top of the hardware stack and leaves their sum at the top of the hardware stack.
Add:
call FreeIntArg0
call FreeIntArg1
ld de,IntArg0
ld hl,IntArg1
ld	b,3
scf
ccf
_AddLoop:
ld	a,(de)
adc a,(hl)
ld	(de),a
inc hl
inc de
djnz _AddLoop
call AllocInt
ld hl,IntArg0
pop de
ld b,3
_AddStoreResultLoop:
ld a,(hl)
ld (de),a
inc hl
inc de
djnz _AddStoreResultLoop ; TODO use ldir instead of manually looping
pop hl
dec de
dec de
dec de
push de
jp (hl)

; .module Disp
; Displays the number at the top of the hardware stack.
; Destroys pretty much every register and flag
; Destroys the inputted number
; TODO stop displaying leading zeroes. 
; TODO right justify
; TODO move number logic to a num2str function and make Disp function display strings
Disp:
call FreeIntArg0
ld de,IntArg0
ld	hl,Ten_Million			; HL is the base 10 number to subtract
ld	b,8				; Number of digits needed to check at max
ld	c,0					; C counts how many subtractions occur before an overflow
_DispLoop:
push bc
ld	b,2
scf
ccf
_DispSubLoop:
ld	a,(de)
sbc a,(hl)
ld	(de),a
inc hl
inc de
djnz _DispSubLoop
pop bc
ld	a,(de)
sbc a,(hl)				; Last subtraction goes outside of loop to check underflow
ld	(de),a
dec de					; Reset DE for next subtraction.
dec de
dec hl					; Reset HL for next subtraction. (there may be a more efficient way to subtract 3)
dec hl
jr	nc,_DispNoUnderflow	; Check for underflow with carry register
ld	a,'0'
add a,c
bcall(_PutC)
ld	c,0
push bc
ld	b,3
_DispAddLoop:
ld	a,(de)
adc a,(hl)
ld	(de),a
inc de
inc hl
djnz	_DispAddLoop
dec de
dec de
dec de
pop bc
dec b
jr	z,_DispEnd
jr	_DispSkipUnderflow
_DispNoUnderflow:
inc c
_DispSkipUnderflow:
jr	_DispLoop
_DispEnd:
bcall(_NewLine)
ret

;.module LoadIntVar 
; Location of Int Var stored in de
LoadIntVar:
ld	hl,(TempPtr)
ld	b,3
_LoadIntVar:
ld	a,(de)
ld	(hl),a
inc hl
inc de
djnz		_LoadIntVar
dec hl
dec hl
dec hl
pop bc
push hl
push bc
ld	de,(TempPtr)
ld	h,0
ld	l,3
add hl,de
ld	(TempPtr),hl
ret

AllocPrev:
.dw $0000
;.module Alloc
; allocates c bytes on the heap and returns a pointer to those bytes.
; Does not coalesce. Max size is 256 (1 byte).
; Because no coalesce, will not split chunks. 
; Possible to  ask for 3 bytes and get a 256 byte chunk.
; struct Block {
; 		Next*		2 byte
; 		Size		1 byte
;		Payload	x byte
; }
; 1. Find a block
; 2. Change the previous block to point where its next block points
; 3. Set the size of the data in the structure
; 4. Push a pointer to the block and return
Alloc:
ld b,0
ld hl,Heap
_AllocFindMemLoop:
ld a,(hl)
inc hl
or (hl) ; check if hl is 00.
jr _AllocSplitEnd
inc hl
ld a,(hl) ; load capacity into a
cp c
jr z,_AllocNoSplit
jr nc,_AllocSplit
dec hl
ld de,AllocPrev+1 ; Save the location of the previous block
ld a,(hl)
ld (de),a
dec hl
dec de
ld a,(hl)
ld (de),a
ld d,0
ld e,c
scf
ccf
adc hl,de ; Jump hl to look at next block
jr _AllocFindMemLoop
_AllocSplit:
; TODO write this to actually split once coalescing works. 
; Tradeoff between internal and external fragmentation
ld c,a
_AllocNoSplit:
; Push and change the previous block to point to this block's next
inc hl
push hl
ld de,(AllocPrev)
dec hl ; hl points to size
ld (hl),c
dec hl
dec hl ; hl points to next*
ld a,(hl)
ld (de),a
inc hl
inc de
ld a,(hl)
ld (de),a
pop de
pop hl
push de
jp (hl) ; Return
_AllocSplitEnd:
inc hl ; hl points to the size
ld (hl),c
inc hl ; hl points to the payload
push hl
ld d,0
ld e,(hl)
add hl,de ; Change hl to point to the new start of blank memory
ld de,(AllocPrev)
ld a,l ; Load in little endian order
ld (de),a
inc de
ld a,h
ld (de),a
ld (hl),0 ; Set the next pointer of the end bank to 00
inc hl
ld (hl),0
pop de
pop hl
push de
jp (hl) ; Return

;.module Free
; Frees the memory pointed to at the top of the stack
pop de
pop hl
push de
dec 

Billion:
.db $00, $CA, $9A, $3B
Hundred_Million:
.db $00, $E1, $F5, $05
Ten_Million:
.db $80, $96, $98
Million:
.db $40, $42, $0F
Hundred_Thousand:
.db $A0, $86, $01
Ten_Thousand:
.db $10, $27, $00
Thousand:
.db $E8, $03, $00
Hundred:
.db $64, $00, $00
Ten:
.db $0A, $00, $00
One:
.db $01, $00, $00

IntArg0:
.db $00, $00, $00
IntArg1:
.db $00, $00, $00

; Table of IntVars (A-Z)
IntVar:
.ds $4E, $0

TempPtr:
; Just make the compiler happy, take out later
FreePtr:
.dw Heap

Heap:
.dw $00
