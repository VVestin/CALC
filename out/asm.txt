#include "ti83plus.inc"
#define progStart $9D95
#define divScratch $8000
.org progStart-2
.db $BB,$6D
	call Setup
	ld bc,$48C6
	ld de,$6A84
	call PushIntLiteral
	ld bc,$2222
	ld de,$2222
	call PushIntLiteral
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$00
	call PushIntLiteral1Byte
	ld bc,$1111
	ld de,$1111
	call PushIntLiteral
	ld bc,$37B5
	ld de,$5973
	call PushIntLiteral
	ld a,8
	call PushListLiteral
	ld de,ListVar+2
	call StoStrVar
	ld bc,$F0FF
	ld de,$FFFF
	call PushIntLiteral
	ld bc,$0FFF
	ld de,$FFFF
	call PushIntLiteral
	ld bc,$FFF0
	ld de,$FFFF
	call PushIntLiteral
	ld bc,$FF0F
	ld de,$FFFF
	call PushIntLiteral
	ld bc,$FFFF
	ld de,$F0FF
	call PushIntLiteral
	ld bc,$FFFF
	ld de,$0FFF
	call PushIntLiteral
	ld bc,$FFFF
	ld de,$FFF0
	call PushIntLiteral
	ld bc,$FFFF
	ld de,$FF0F
	call PushIntLiteral
	ld a,8
	call PushListLiteral
	ld de,ListVar+4
	call StoStrVar
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call StoIntVar
ForLoop1:
	ld de,IntVar+96
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	call CompareEqual
	ld hl,ForLoopEnd1
	call If
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+92
	call StoIntVar
ForLoop2:
	ld de,IntVar+92
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	call CompareEqual
	ld hl,ForLoopEnd2
	call If
	call FunOUTPre
	ld hl,String2
	call PushStringLiteral
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+96
	call LoadIntVar
	call FunOUT
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call StoIntVar
	jp ForLoop2
ForLoopEnd2:
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+96
	call StoIntVar
	jp ForLoop1
ForLoopEnd1:
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+48
	call StoIntVar
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+52
	call StoIntVar
	ld b,$03
	call PushIntLiteral1Byte
	ld de,IntVar+92
	call StoIntVar
	ld b,$03
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call StoIntVar
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+60
	call StoIntVar
	call FunOUTPre
	ld hl,String3
	call PushStringLiteral
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+96
	call LoadIntVar
	call FunOUT
RepeatLoop1:
RepeatLoop2:
	call GetKey
	ld de,IntVar+40
	call StoIntVar
	ld de,IntVar+40
	call LoadIntVar
	ld hl,RepeatLoop2
	call If
	call FunGETPre
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunGET
	ld de,IntVar+8
	call StoIntVar
	ld de,IntVar+40
	call LoadIntVar
	ld b,$04
	call PushIntLiteral1Byte
	scf
	call CompareEqual
	ld hl,If1
	call if
	call FunOUTPre
	ld hl,String4
	call PushStringLiteral
	ld b,$01
	call PushIntLiteral1Byte
	call FunGETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunGETMOV
	ld b,$00
	call PushIntLiteral1Byte
	call Equals
	call Not
	call SubString
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+96
	call LoadIntVar
	call FunOUT
	ld de,IntVar+40
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Equals
	ld de,IntVar+96
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	call Compare
	call And
	ld hl,If2
	call if
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+96
	call StoIntVar
	jp IfEnd2
If2:
	ld de,IntVar+40
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Equals
	ld de,IntVar+92
	call LoadIntVar
	ld b,$00
	call PushIntLiteral1Byte
	scf
	ccf
	call Compare
	call And
	ld hl,If3
	call If
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call StoIntVar
	jp IfEnd2
If3:
	ld de,IntVar+40
	call LoadIntVar
	ld b,$03
	call PushIntLiteral1Byte
	call Equals
	ld de,IntVar+92
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	call Compare
	call And
	ld hl,If4
	call If
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call StoIntVar
	jp IfEnd2
If4:
	ld de,IntVar+40
	call LoadIntVar
	ld b,$04
	call PushIntLiteral1Byte
	call Equals
	ld de,IntVar+96
	call LoadIntVar
	ld b,$00
	call PushIntLiteral1Byte
	scf
	ccf
	call Compare
	call And
	ld hl,If5
	call If
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+96
	call StoIntVar
	jp IfEnd2
If5:
IfEnd2:
	call FunOUTPre
	ld hl,String5
	call PushStringLiteral
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+96
	call LoadIntVar
	call FunOUT
	jp IfEnd1
If1:
	ld de,IntVar+40
	call LoadIntVar
	ld bc,$3600
	ld de,$0000
	call PushIntLiteral
	call Equals
	ld hl,If7
	call If
	ld de,IntVar+52
	call LoadIntVar
	ld de,IntVar+48
	call LoadIntVar
	call Or
	ld hl,If8
	call if
	call FunGETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunGETMOV
	ld hl,If9
	call if
	call FunSETPre
	call FunGETPre
	ld de,IntVar+76
	call LoadIntVar
	ld de,IntVar+72
	call LoadIntVar
	call FunGET
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunSET
	call FunSETPre
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+76
	call LoadIntVar
	ld de,IntVar+72
	call LoadIntVar
	call FunSET
	call FunOUTPre
	ld hl,String6
	call PushStringLiteral
	ld de,IntVar+72
	call LoadIntVar
	ld de,IntVar+76
	call LoadIntVar
	call FunOUT
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+0
	call StoIntVar
ForLoop3:
	ld de,IntVar+0
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	call CompareEqual
	ld hl,ForLoopEnd3
	call If
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+4
	call StoIntVar
ForLoop4:
	ld de,IntVar+4
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	call CompareEqual
	ld hl,ForLoopEnd4
	call If
	call FunGETMOVPre
	ld de,IntVar+4
	call LoadIntVar
	ld de,IntVar+0
	call LoadIntVar
	call FunGETMOV
	ld hl,If10
	call if
	call FunOUTPre
	ld hl,String7
	call PushStringLiteral
	ld de,IntVar+0
	call LoadIntVar
	ld de,IntVar+4
	call LoadIntVar
	call FunOUT
	jp IfEnd10
If10:
IfEnd10:
	ld de,IntVar+4
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+4
	call StoIntVar
	jp ForLoop4
ForLoopEnd4:
	ld de,IntVar+0
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+0
	call StoIntVar
	jp ForLoop3
ForLoopEnd3:
	call FunOUTPre
	ld hl,String8
	call PushStringLiteral
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+96
	call LoadIntVar
	call FunOUT
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+52
	call StoIntVar
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+48
	call StoIntVar
	ld de,IntVar+60
	call LoadIntVar
	call Not
	ld de,IntVar+60
	call StoIntVar
	jp IfEnd9
If9:
IfEnd9:
	jp IfEnd8
If8:
	ld de,IntVar+8
	call LoadIntVar
	ld de,IntVar+8
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call BitAnd
	ld de,IntVar+60
	call LoadIntVar
	call Equals
	call And
	ld hl,If13
	call If
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+72
	call StoIntVar
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+76
	call StoIntVar
	ld de,IntVar+8
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Equals
	ld hl,If14
	call if
	call FunGETPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	call FunGET
	call Not
	ld hl,If15
	call if
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	call FunSETMOV
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Equals
	call FunGETPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	call FunGET
	call Not
	call And
	ld hl,If16
	call if
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	call FunSETMOV
	jp IfEnd16
If16:
IfEnd16:
	jp IfEnd15
If15:
IfEnd15:
	ld de,IntVar+92
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	call Compare
	call FunGETPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	call FunGET
	call And
	ld hl,If19
	call if
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	call FunSETMOV
	jp IfEnd19
If19:
IfEnd19:
	ld de,IntVar+92
	call LoadIntVar
	ld b,$00
	call PushIntLiteral1Byte
	scf
	ccf
	call Compare
	call FunGETPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	call FunGET
	call And
	ld hl,If21
	call if
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	call FunSETMOV
	jp IfEnd21
If21:
IfEnd21:
	jp IfEnd14
If14:
	ld de,IntVar+8
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Equals
	ld hl,If23
	call If
	call FunGETPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	call FunGET
	call Not
	ld hl,If24
	call if
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	call FunSETMOV
	ld de,IntVar+96
	call LoadIntVar
	ld b,$06
	call PushIntLiteral1Byte
	call Equals
	call FunGETPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	call FunGET
	call Not
	call And
	ld hl,If25
	call if
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	call FunSETMOV
	jp IfEnd25
If25:
IfEnd25:
	jp IfEnd24
If24:
IfEnd24:
	ld de,IntVar+92
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	call Compare
	call FunGETPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	call FunGET
	call And
	ld hl,If28
	call if
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	call FunSETMOV
	jp IfEnd28
If28:
IfEnd28:
	ld de,IntVar+92
	call LoadIntVar
	ld b,$00
	call PushIntLiteral1Byte
	scf
	ccf
	call Compare
	call FunGETPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	call FunGET
	call And
	ld hl,If30
	call if
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	call FunSETMOV
	jp IfEnd30
If30:
IfEnd30:
	jp IfEnd14
If23:
	ld de,IntVar+8
	call LoadIntVar
	ld b,$05
	call PushIntLiteral1Byte
	scf
	call Compare
	ld hl,If32
	call If
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Add
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Add
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Negate
	call Add
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$02
	call PushIntLiteral1Byte
	call Negate
	call Add
	call FunSETMOV
	jp IfEnd14
If32:
	ld de,IntVar+8
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	call Compare
	ld hl,If33
	call If
	call FunLINEPre
	ld b,$01
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	call FunLINEPre
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld b,$01
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	call FunLINEPre
	ld b,$01
	call PushIntLiteral1Byte
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	call FunLINEPre
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	jp IfEnd14
If33:
	ld de,IntVar+8
	call LoadIntVar
	ld b,$09
	call PushIntLiteral1Byte
	scf
	call Compare
	ld hl,If34
	call If
	call FunLINEPre
	ld b,$01
	call PushIntLiteral1Byte
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	call FunLINEPre
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	call FunLINEPre
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	call FunLINEPre
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	jp IfEnd14
If34:
	ld de,IntVar+8
	call LoadIntVar
	ld b,$0B
	call PushIntLiteral1Byte
	scf
	call Compare
	ld hl,If35
	call If
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	call FunSETMOV
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+92
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	call FunSETMOV
	jp IfEnd14
If35:
	call FunLINEPre
	ld b,$01
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	call FunLINEPre
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld b,$01
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	call FunLINEPre
	ld b,$01
	call PushIntLiteral1Byte
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	call FunLINEPre
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	call FunLINEPre
	ld b,$01
	call PushIntLiteral1Byte
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	call FunLINEPre
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	call FunLINEPre
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	call FunLINEPre
	ld b,$00
	call PushIntLiteral1Byte
	ld b,$01
	call PushIntLiteral1Byte
	call Negate
	call Add
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunLINE
	jp IfEnd14
If36:
IfEnd14:
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+0
	call StoIntVar
ForLoop5:
	ld de,IntVar+0
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	call CompareEqual
	ld hl,ForLoopEnd5
	call If
	ld b,$00
	call PushIntLiteral1Byte
	ld de,IntVar+4
	call StoIntVar
ForLoop6:
	ld de,IntVar+4
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	call CompareEqual
	ld hl,ForLoopEnd6
	call If
	call FunGETMOVPre
	ld de,IntVar+4
	call LoadIntVar
	ld de,IntVar+0
	call LoadIntVar
	call FunGETMOV
	ld hl,If38
	call if
	call FunOUTPre
	ld hl,String9
	call PushStringLiteral
	ld de,IntVar+0
	call LoadIntVar
	ld de,IntVar+4
	call LoadIntVar
	call FunOUT
	jp IfEnd38
If38:
IfEnd38:
	ld de,IntVar+4
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+4
	call StoIntVar
	jp ForLoop6
ForLoopEnd6:
	ld de,IntVar+0
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call Add
	ld de,IntVar+0
	call StoIntVar
	jp ForLoop5
ForLoopEnd5:
	jp IfEnd8
If13:
IfEnd8:
	jp IfEnd1
If7:
IfEnd1:
	ld de,IntVar+40
	call LoadIntVar
	ld b,$0F
	call PushIntLiteral1Byte
	call Equals
	ld hl,RepeatLoop1
	call If
	call ClrHome
	call Stop
	
String1:
.db 13," PpNnBbRrKkQq"
FunGETCHARPre:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+96
	call LoadIntVar
	ld hl,(FuncTemp)
	jp (hl)
FunGETCHAR:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+92
	call StoIntVar
	ld de,IntVar+96
	call StoIntVar
	ld hl,(FuncTemp)
	push hl
	call FunGETPre
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunGET
	ld de,IntVar+8
	call StoIntVar
	ld hl,String1
	call PushStringLiteral
	ld b,$01
	call PushIntLiteral1Byte
	ld de,IntVar+8
	call LoadIntVar
	call SubString
	jp FunReturnGETCHAR
FunReturnGETCHAR:
	pop hl
	ld (FuncRet),hl
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+96
	call StoIntVar
	ld de,IntVar+92
	call StoIntVar
	ld hl,(FuncRet)
	push hl
	ld hl,(FuncTemp)
	jp (hl)
FunDLYPre:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+76
	call LoadIntVar
	ld hl,(FuncTemp)
	jp (hl)
FunDLY:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+76
	call StoIntVar
	ld hl,(FuncTemp)
	push hl
	call GetTime
	ld de,IntVar+76
	call LoadIntVar
	call Add
	ld de,IntVar+76
	call StoIntVar
RepeatLoop3:
	call GetTime
	ld de,IntVar+76
	call LoadIntVar
	call Equals
	ld hl,RepeatLoop3
	call If
FunReturnDLY:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+76
	call StoIntVar
	ld hl,(FuncTemp)
	jp (hl)
FunGETPre:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+96
	call LoadIntVar
	ld hl,(FuncTemp)
	jp (hl)
FunGET:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+92
	call StoIntVar
	ld de,IntVar+96
	call StoIntVar
	ld hl,(FuncTemp)
	push hl
	ld de,IntVar+92
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	ccf
	call Compare
	ld de,IntVar+96
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	ccf
	call Compare
	call Or
	ld hl,If42
	call if
	ld b,$01
	call PushIntLiteral1Byte
	jp FunReturnGET
	jp IfEnd42
If42:
IfEnd42:
	ld de,IntVar+96
	call LoadIntVar
	ld hl,(ListVar+2)
	call ListVarGet
	ld b,$04
	call PushIntLiteral1Byte
	ld de,IntVar+92
	call LoadIntVar
	call Mult
	push hl
	call FreeIntArg0
	pop hl
	ld hl,IntArg0
	ld b,(hl)
	call ShiftLeft
	ld b,28
	call ShiftRight
	jp FunReturnGET
FunReturnGET:
	pop hl
	ld (FuncRet),hl
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+96
	call StoIntVar
	ld de,IntVar+92
	call StoIntVar
	ld hl,(FuncRet)
	push hl
	ld hl,(FuncTemp)
	jp (hl)
FunSETPre:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+84
	call LoadIntVar
	ld hl,(FuncTemp)
	jp (hl)
FunSET:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+92
	call StoIntVar
	ld de,IntVar+96
	call StoIntVar
	ld de,IntVar+84
	call StoIntVar
	ld hl,(FuncTemp)
	push hl
	ld de,IntVar+96
	call LoadIntVar
	ld hl,(ListVar+2)
	call ListVarGet
	ld de,IntVar+92
	call LoadIntVar
	ld hl,(ListVar+4)
	call ListVarGet
	call BitAnd
	ld de,IntVar+84
	call LoadIntVar
	ld b,$04
	call PushIntLiteral1Byte
	ld b,$07
	call PushIntLiteral1Byte
	ld de,IntVar+92
	call LoadIntVar
	call Negate
	call Add
	call Mult
	push hl
	call FreeIntArg0
	pop hl
	ld hl,IntArg0
	ld b,(hl)
	call ShiftLeft
	call BitOr
	ld de,ListVar+2
	; Address is ListVar+2
	; Id is [Identifier L1]
	push de
	ld de,IntVar+96
	call LoadIntVar
	call ListSet
FunReturnSET:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+84
	call StoIntVar
	ld de,IntVar+96
	call StoIntVar
	ld de,IntVar+92
	call StoIntVar
	ld hl,(FuncTemp)
	jp (hl)
FunSETMOVPre:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+96
	call LoadIntVar
	ld hl,(FuncTemp)
	jp (hl)
FunSETMOV:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+92
	call StoIntVar
	ld de,IntVar+96
	call StoIntVar
	ld hl,(FuncTemp)
	push hl
	ld de,IntVar+92
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	ccf
	call Compare
	ld de,IntVar+96
	call LoadIntVar
	ld b,$07
	call PushIntLiteral1Byte
	scf
	ccf
	call Compare
	call Or
	ld hl,If44
	call if
	jp FunReturnSETMOV
	jp IfEnd44
If44:
IfEnd44:
	call FunGETPre
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunGET
	ld de,IntVar+0
	call StoIntVar
	ld de,IntVar+0
	call LoadIntVar
	ld de,IntVar+0
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call BitAnd
	ld de,IntVar+8
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	call BitAnd
	call Equals
	call And
	ld hl,If46
	call if
	jp FunReturnSETMOV
	jp IfEnd46
If46:
IfEnd46:
	ld de,IntVar+96
	call LoadIntVar
	ld b,$04
	call PushIntLiteral1Byte
	scf
	call Compare
	ld hl,If48
	call if
	ld de,IntVar+52
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	ld b,$08
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	call Mult
	ld de,IntVar+92
	call LoadIntVar
	call Add
	push hl
	call FreeIntArg0
	pop hl
	ld hl,IntArg0
	ld b,(hl)
	call ShiftLeft
	call BitOr
	ld de,IntVar+52
	call StoIntVar
	jp IfEnd48
If48:
	ld de,IntVar+48
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	ld b,$08
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	ld b,$04
	call PushIntLiteral1Byte
	call Negate
	call Add
	call Mult
	ld de,IntVar+92
	call LoadIntVar
	call Add
	push hl
	call FreeIntArg0
	pop hl
	ld hl,IntArg0
	ld b,(hl)
	call ShiftLeft
	call BitOr
	ld de,IntVar+48
	call StoIntVar
	jp IfEnd48
If49:
IfEnd48:
FunReturnSETMOV:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+96
	call StoIntVar
	ld de,IntVar+92
	call StoIntVar
	ld hl,(FuncTemp)
	jp (hl)
FunGETMOVPre:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+96
	call LoadIntVar
	ld hl,(FuncTemp)
	jp (hl)
FunGETMOV:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+92
	call StoIntVar
	ld de,IntVar+96
	call StoIntVar
	ld hl,(FuncTemp)
	push hl
	ld de,IntVar+96
	call LoadIntVar
	ld b,$04
	call PushIntLiteral1Byte
	scf
	call Compare
	ld hl,If51
	call if
	ld de,IntVar+52
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	ld b,$08
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	call Mult
	ld de,IntVar+92
	call LoadIntVar
	call Add
	push hl
	call FreeIntArg0
	pop hl
	ld hl,IntArg0
	ld b,(hl)
	call ShiftLeft
	call BitAnd
	jp FunReturnGETMOV
	jp IfEnd51
If51:
	ld de,IntVar+48
	call LoadIntVar
	ld b,$01
	call PushIntLiteral1Byte
	ld b,$08
	call PushIntLiteral1Byte
	ld de,IntVar+96
	call LoadIntVar
	ld b,$04
	call PushIntLiteral1Byte
	call Negate
	call Add
	call Mult
	ld de,IntVar+92
	call LoadIntVar
	call Add
	push hl
	call FreeIntArg0
	pop hl
	ld hl,IntArg0
	ld b,(hl)
	call ShiftLeft
	call BitAnd
	jp FunReturnGETMOV
	jp IfEnd51
If52:
IfEnd51:
FunReturnGETMOV:
	pop hl
	ld (FuncRet),hl
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+96
	call StoIntVar
	ld de,IntVar+92
	call StoIntVar
	ld hl,(FuncRet)
	push hl
	ld hl,(FuncTemp)
	jp (hl)
FunLINEPre:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+32
	call LoadIntVar
	ld de,IntVar+36
	call LoadIntVar
	ld hl,(FuncTemp)
	jp (hl)
FunLINE:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+92
	call StoIntVar
	ld de,IntVar+96
	call StoIntVar
	ld de,IntVar+32
	call StoIntVar
	ld de,IntVar+36
	call StoIntVar
	ld hl,(FuncTemp)
	push hl
RepeatLoop4:
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+32
	call LoadIntVar
	call Add
	ld de,IntVar+92
	call StoIntVar
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+36
	call LoadIntVar
	call Add
	ld de,IntVar+96
	call StoIntVar
	call FunSETMOVPre
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunSETMOV
	call FunGETPre
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunGET
	ld hl,RepeatLoop4
	call If
FunReturnLINE:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+36
	call StoIntVar
	ld de,IntVar+32
	call StoIntVar
	ld de,IntVar+96
	call StoIntVar
	ld de,IntVar+92
	call StoIntVar
	ld hl,(FuncTemp)
	jp (hl)
FunOUTPre:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	ld de,StrVar+2
	call LoadStrVar
	ld hl,(FuncTemp)
	jp (hl)
FunOUT:
	pop hl
	ld (FuncTemp),hl
	ld de,IntVar+96
	call StoIntVar
	ld de,IntVar+92
	call StoIntVar
	ld de,StrVar+2
	call StoStrVar
	ld hl,(FuncTemp)
	push hl
	ld de,IntVar+92
	call LoadIntVar
	ld de,IntVar+96
	call LoadIntVar
	call Add
	ld b,$01
	call PushIntLiteral1Byte
	call BitAnd
	ld hl,If54
	call if
	set TextInverse,(IY + TextFlags)
	ld de,StrVar+2
	call LoadStrVar
	call FunGETCHARPre
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunGETCHAR
	call Concat
	ld de,IntVar+92
	call LoadIntVar
	ld b,1
	call ShiftLeft
	ld de,IntVar+96
	call LoadIntVar
	call Output
	res TextInverse,(IY + TextFlags)
	jp IfEnd54
If54:
	ld de,StrVar+2
	call LoadStrVar
	call FunGETCHARPre
	ld de,IntVar+96
	call LoadIntVar
	ld de,IntVar+92
	call LoadIntVar
	call FunGETCHAR
	call Concat
	ld de,IntVar+92
	call LoadIntVar
	ld b,1
	call ShiftLeft
	ld de,IntVar+96
	call LoadIntVar
	call Output
	jp IfEnd54
If55:
IfEnd54:
FunReturnOUT:
	pop hl
	ld (FuncTemp),hl
	ld de,StrVar+2
	call StoStrVar
	ld de,IntVar+92
	call StoIntVar
	ld de,IntVar+96
	call StoIntVar
	ld hl,(FuncTemp)
	jp (hl)
String2:
.db 1," "
String3:
.db 1,">"
String4:
.db 2," *"
String5:
.db 1,">"
String6:
.db 1," "
String7:
.db 1," "
String8:
.db 1,">"
String9:
.db 1,"*"
	;.module Setup
	; Does all of the setup necessary to run a program.
	; Currently this is only setting InitStack for Stop to work
	; Must be called first thing on  run program
Setup:
	bcall(_ClrLCDFull)
	bcall(_HomeUp)
	pop bc
	ld (InitStack),sp
	push bc
	; TODO set LSFR seed to a random number (register R and System time?)
	;di
	;ld hl,InterruptHandler
	;ld ($993F),hl
	;ld ($997F),hl
	;ld ($99BF),hl
	;ld ($99FF),hl
	;ld a,$99
	;ld i,a
	;ld a,%1101
	;out (3),a
	;im 2
	;ei 
	ret
	
	;.module InterruptHandler
	; Handles interrupts. Checks if bit 0 of port 4 is set (Means Interrupt Caused By [ON]).
InterruptHandler:
	ex  af, af'
	exx
	xor a 
	out (3), a
	in a,(4)
	cp $8
	jr z,_InterruptNotON
	pop bc
	ld a, %1101 
	out (3), a
	ex af, af'
	exx
	ei
	call Stop
_InterruptNotON:
	ld a, %1101 
	out (3), a
	ex af, af'
	exx
	ei
	ret
	
	;.module FreeIntArg0
	; Puts the integer at one below the top of the stack into IntArg0 and then frees it
FreeIntArg0:
	pop bc
	pop de
	pop hl ; hl is the int to free
	push de
	push bc
	push hl
	ld de,IntArg0
	ld b,4
_FreeIntArg0Loop:
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	djnz _FreeIntArg0Loop
	call Free
	ret
	
	;.module FreeIntArg1
	; Puts the integer at one below the top of the stack into IntArg1 and then frees it
FreeIntArg1:
	pop bc
	pop de
	pop hl ; hl is the int to free
	push de
	push bc
	push hl
	ld de,IntArg1
	ld b,4
_FreeIntArg1Loop:
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	djnz _FreeIntArg1Loop
	call Free
	ret
	
	;.module Pause
	; TODO make it only accept the enter key
Pause:
	bcall(_GetKey)
	ret
	
	;.module ClrHome
ClrHome:
	bcall(_ClrScrnFull)
	bcall(_HomeUp)
	ret
	
	;.module Stop
Stop:
	ld sp,(InitStack)
	res 5,(iy+0) 
	im 1
	ret
	
	;.module If
	; Checks the value on top of the stack, if it is false jumps to hl
	; What was I thinking when I wrote this the first time?
If:
	ex de,hl ; hl is just easier to work with
	pop bc
	pop hl ; Number to check
	push bc
	xor a ; Zero out a
	ld b,4
_IfCheckLoop:
	ld c,(hl)
	inc hl
	or c
	djnz _IfCheckLoop
	dec hl
	dec hl
	dec hl
	dec hl
	jp nz,_IfTrue
	pop bc
	push de ; Swap return address to de
_IfTrue:
	push hl
	call Free
	ret
	
	;.module PushStringLiteral
	; Allocates and pushes a pointer to a copy of the string string at hl
PushStringliteral:
	push hl
	ld c,(hl)
	inc c
	call Alloc
	pop de ; Pointer to the allocated chunk
	pop hl ; Pointer to the string literal
	push de
	ld b,(hl)
	inc b
_PushStringLiteralLoadLoop:
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	or a
	djnz _PushStringLiteralLoadLoop
	pop de
	pop hl
	push de
	jp (hl)
	
	;.module PushIntLiteral
	; Pushes the number in bc (lsb) and de (msb) 
PushIntLiteral:
	push de
	push bc
	ld c,4
	call Alloc
	pop hl
	pop bc
	pop de
	ld (hl),b
	inc hl
	ld (hl),c
	inc hl
	ld (hl),d
	inc hl
	ld (hl),e
	pop de
	dec hl
	dec hl
	dec hl
	push hl
	ex de,hl
	jp (hl)
	
	;.module PushIntLiteral3Byte
	; Pushes the number in bcd to stack
PushIntLiteral3Byte:
	push de
	push bc
	ld c,4
	call Alloc
	pop hl
	pop bc
	pop de
	ld (hl),b
	inc hl
	ld (hl),c
	inc hl
	ld (hl),d
	inc hl
	ld (hl),0
	pop de
	dec hl
	dec hl
	dec hl
	push hl
	ex de,hl
	jp (hl)
	
	;.module PushIntLiteral2Byte
	; Pushes the number in bc to stack
PushIntLiteral2Byte:
	push de
	push bc
	ld c,4
	call Alloc
	pop hl
	pop bc
	pop de
	ld (hl),b
	inc hl
	ld (hl),c
	inc hl
	ld (hl),0
	inc hl
	ld (hl),0
	pop de
	dec hl
	dec hl
	dec hl
	push hl
	ex de,hl
	jp (hl)
	
	;.module PushIntLiteral1Byte
	; Pushes the number in b to stack
PushIntLiteral1Byte:
	push de
	push bc
	ld c,4
	call Alloc
	pop hl
	pop bc
	pop de
	ld (hl),b
	inc hl
	ld (hl),0
	inc hl
	ld (hl),0
	inc hl
	ld (hl),0
	pop de
	dec hl
	dec hl
	dec hl
	push hl
	ex de,hl
	jp (hl)
	
NewList:
.dw $00
PushListRetLoc:
.dw $00
	;.module PushListLiteral
	; Pushes a integers from the stack onto a new list and leaves the list on the stack
PushListLiteral:
	pop hl
	ld (PushListRetLoc),hl
	ld b,a
	add a,a
	add a,a ; Multiply a by 4
	inc a ; Add 1 for size byte
	ld c,a
	push bc
	call Alloc
	pop hl ; pointer to new list
	pop bc
	ld (NewList),hl
	ld (hl),b
	inc hl
_PushListLiteralLoop:
	pop de
	ld a,(de)
	ld (hl),a
	inc de
	inc hl
	ld a,(de)
	ld (hl),a
	inc de
	inc hl
	ld a,(de)
	ld (hl),a
	inc de
	inc hl
	ld a,(de)
	ld (hl),a
	inc hl
	dec de
	dec de
	dec de
	push bc
	push hl
	push de
	call Free
	pop hl
	pop bc
	djnz _PushListLiteralLoop
	ld de,(NewList)
	push de
	ld hl,(PushListRetLoc)
	jp (hl)
	
	;.module LoadListVar
	; Location of StrVar stored in de
LoadListVar:
	ld a,(de)
	ld l,a
	inc de
	ld a,(de)
	ld h,a
	ld a,(hl)
	add a,a
	add a,a
	ld c,a
	inc c
	push hl
	call Alloc
	pop de ; New list
	pop hl ; List var
	push de
	ld b,(hl)
	ld a,b
	add a,a
	add a,a
	ld b,a
	inc b
_LoadListVarLoop:
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	djnz _LoadListVarLoop
	pop de
	pop hl
	push de
	jp (hl)
	
	;.module StoIntVar
	; Takes 4 bytes from the number at the top of the stack and moves them to de
StoIntVar:
	pop bc
	pop hl
	push bc
	push hl
	ld b,0
	ld c,4
	ldir
	call Free
	ret
	
	;.module StoStrVar
	; Takes the string at the top of the stack and stores a pointer to it in de
	; Checks if there is already a string stored there and frees it
StoStrVar:
	ld a,(de)
	ld b,a
	inc de
	ld a,(de)
	or b
	jr z,_StoStrVarSkipFree
	ld l,b
	ld a,(de)
	ld h,a
	push de
	push hl
	call Free
	pop de
_StoStrVarSkipFree:
	pop bc
	pop hl
	push bc
	dec de
	ld a,l
	ld (de),a
	inc de
	ld a,h
	ld (de),a
	ret
	
	;.module Negate
	; Negates the 3 byte integer at the top of the stack
Negate:
	pop bc
	pop hl
	push hl
	push bc
	ld a,(hl)
	ld b,4
	scf
	ccf
_NegateCPLLoop:
	ld a,0
	sbc a,(hl)
	ld (hl),a
	inc hl
	djnz _NegateCPLLoop
	ret
	
	;.module AbsValue
	; If negative the, number at the top of the stack is negative it is negated
AbsValue:
	pop hl
	pop de
	push de
	push hl
	inc de
	inc de
	inc de ; Look at MSB
	ld a,(de)
	bit 7,a ; Look at sign bit
	jr z,_AbsValueSkipNegate
	call Negate
_AbsValueSkipNegate:
	ret
	
	;.module Compare
	; Compares two numbers at the top of the stack
	; Does a greater than if carry is set, otherwise a less than
	; FIXED start comparison at MSB not LSB
Compare:
	call FreeIntArg0
	call FreeIntArg1
	ld hl,IntArg0+3
	ld de,IntArg1+3
	jr c, _CompareGreater ; Luckily, carry is spared after FreeIntArg. This is dangerous
	ld de,IntArg0+3
	ld hl,IntArg1+3
_CompareGreater:
	ld b,4
_CompareLoop:
	ld a,(de)
	cp (hl)
	jr c,_CompareTrue
	jr nz,_CompareFalse
	dec de
	dec hl
	djnz _CompareLoop
_CompareFalse:
	ld b,0
	jp _EqualsPushResult
_CompareTrue:
	ld b,1
	jp _EqualsPushResult
	
	;.module CompareEqual (<= and >=)
	; Compares two numbers at the top of the stack
	; Does a greater than if carry is set, otherwise a less than
CompareEqual:
	call FreeIntArg0
	call FreeIntArg1
	ld hl,IntArg0+3
	ld de,IntArg1+3
	jr c, _CompareEqualGreater
	ld de,IntArg0+3
	ld hl,IntArg1+3
_CompareEqualGreater:
	ld b,4
_CompareEqualLoop:
	ld a,(de)
	cp (hl)
	jr c,_CompareEqualTrue
	jr nz,_CompareEqualFalse
	dec hl
	dec de
	djnz _CompareEqualLoop
_CompareEqualTrue:
	ld b,1
	jp _EqualsPushResult
_CompareEqualFalse:
	ld b,0
	jp _EqualsPushResult
	
	;.module Or
	; Looks at two numbes on top of the stack. Pushes on a 1 if either is nonzero, otherwise a 0.
Or:
	call FreeIntArg0
	call FreeIntArg1
	ld hl,IntArg0
	ld de,IntArg1
	ld b,4
_OrLoop:
	ld a,(de)
	or a
	jr nz, _OrTrue
	ld a,(hl)
	or a
	jr nz, _OrTrue
	inc hl
	inc de
	djnz _OrLoop
	ld b,0
	jr _EqualsPushResult
_OrTrue:
	ld b,1
	jr _EqualsPushResult
	
	;.module And
	; Looks at two numbers on top of the stack. Pushes on a 1 if both are nonzero, otherwise a 0.
And:
	call FreeIntArg0
	call FreeIntArg1
	ld hl,IntArg0
	ld de,IntArg1
	ld b,4
_AndLoop1:
	ld a,(de)
	or a
	jr nz,_AndPartTrue
	inc de
	djnz _AndLoop1
	ld b,0
	jr _EqualsPushResult
_AndPartTrue:
	ld b,4
_AndLoop2:
	ld a,(hl)
	or a
	jr nz,_AndTrue
	inc hl
	djnz _AndLoop2
	ld b,0
	jr _EqualsPushResult
_AndTrue:
	ld b,1
	jr _EqualsPushResult
	
	;.module Not
	; Looks at number at the top of the stack. pushes a 0 if nonzero and 1 if 0
Not:
	call FreeIntArg0
	ld hl,IntArg0
	ld b,4
_NotLoop:
	ld a,(hl)
	or a
	jr nz,_NotTrue
	inc hl
	djnz _NotLoop
	ld b,1
	jr _EqualsPushResult
_NotTrue:
	ld b,0
	jr _EqualsPushResult
	
	;.module Equals
	; Compares two numbers at the top of the stack for equality, leaving the stack with a 1 if equal
Equals:
	call FreeIntArg0
	call FreeIntArg1
	ld hl,IntArg0
	ld de,IntArg1
	ld b,4
_EqualsLoop:
	ld a,(de)
	cp (hl)
	jr nz,_EqualsNotEqual
	inc hl
	inc de
	djnz _EqualsLoop
	ld b,1
	jr _EqualsPushResult
_EqualsNotEqual:
	ld b,0
_EqualsPushResult:
	push bc
	ld c,4
	call Alloc
	pop hl
	pop bc
	pop de
	push hl
	ld (hl),b
	inc hl
	ld (hl),0
	inc hl
	ld (hl),0
	inc hl
	ld (hl),0
	ex de,hl
	jp (hl)
	
	;.module Rand
	; Generates a random number between 0 and 4,294,967,296 and pushes it onto the stack
Rand:
	ld c,4
	call Alloc
	call RandLFSR
	pop hl
	ld (hl),a
	inc hl
	push hl
	call RandLFSR
	pop hl
	ld (hl),a
	inc hl
	push hl
	call RandLFSR
	pop hl
	ld (hl),a
	inc hl
	push hl
	call RandLFSR
	pop hl
	ld (hl),a
	dec hl
	dec hl
	dec hl
	pop de
	push hl
	ex de,hl
	jp (hl)
	
	;------LFSR------
	;James Montelongo
	;optimized by Spencer Putt
;out:
	; a = 8 bit random number
RandLFSR:
	ld hl,LFSRSeed+4
	ld e,(hl)
	inc hl
	ld d,(hl)
	inc hl
	ld c,(hl)
	inc hl
	ld a,(hl)
	ld b,a
	rl e 
	rl d
	rl c 
	rla
	rl e 
	rl d
	rl c 
	rla
	rl e 
	rl d
	rl c 
	rla
	ld h,a
	rl e 
	rl d
	rl c 
	rla
	xor b
	rl e 
	rl d
	xor h
	xor c
	xor d
	ld hl,LFSRSeed+6
	ld de,LFSRSeed+7
	ld bc,7
	lddr
	ld (de),a
	ret
LFSRSeed:
.db $F1, $11, $EA, $02, $C4, $45, $77, $4A
	
	;.module GetKey
	; Gets the key currently being pressed and pushes it to the stack
GetKey:
	ld c,4
	call Alloc
	bcall(_GetCSC)
	pop hl
	push hl
	ld (hl),a
	inc hl
	ld (hl),$0
	inc hl
	ld (hl),$0
	inc hl
	ld (hl),$0
	pop de
	pop hl
	push de
	jp (hl)
	
;.module GetTime:
	; Gets the unix time from system and pushes it onto the stack
GetTime:
	ld c,4
	call Alloc
	pop de
	pop hl
	push de
	in a,($45)
	ld (de),a
	inc de
	in a,($46)
	ld (de),a
	inc de
	in a,($47)
	ld (de),a
	inc de
	in a,($48)
	ld (de),a
	jp (hl)
	
	;.module Mult
	; Multiplies the two numbers at the top of the stack and leaves the stack with only the result
Mult:
	call FreeIntArg0
	call FreeIntArg1
	ld hl,MultResult
	ld (hl),$0
	inc hl
	ld (hl),$0
	inc hl
	ld (hl),$0
	inc hl
	ld (hl),$0
	ld b,32
_MultLoop:
	push bc
	ld hl,IntArg1+3
	srl (hl)
	dec hl
	ld b,3 ; Shift every remaining byte in IntArg1
_MultShiftLoopB:
	rr (hl)
	dec hl
	djnz _MultShiftLoopB
	jr nc,_MultSkipAdd
	ld hl,IntArg0
	ld de,MultResult
	ld b,4
	xor a
_MultAddLoop:
	ld a,(de)
	adc a,(hl)
	ld (de),a
	inc hl
	inc de
	djnz _MultAddLoop
_MultSkipAdd:
	ld hl,IntArg0
	sla (hl)
	inc hl
	ld b,3
_MultShiftLoopA:
	rl (hl)
	inc hl
	djnz _MultShiftLoopA
	pop bc
	djnz _MultLoop
	ld hl,MultResult
	ld b,(hl)
	inc hl
	ld c,(hl)
	inc hl
	ld d,(hl)
	inc hl
	ld e,(hl) 
	call PushIntLiteral
	pop de
	pop hl
	push de
	jp (hl)
MultResult:
.db $00, $00, $00, $00, $00, $00, $00, $00
	
	;.module Divide
	; Pops 2 numbers off the stack and divides them by one another and pushes the quotient
Divide:
	call FreeIntArg1
	call FreeIntArg0
	call Div24by24
	; edc to bcde
	ld a,c
	ld c,d
	ld d,a
	ld b,e
	ld e,0
	call PushIntLiteral
	pop de
	pop hl
	push de
	jp (hl)
	
	;.module Modulo
	; Pops 2 numbers off the stack and divides them by one another and pushes the remainder
Modulo:
	call FreeIntArg1
	call FreeIntArg0
	call Div24by24
	; lha to bcde
	ld e,0
	ld d,a
	ld c,h
	ld b,l
	call pushIntLiteral
	pop de
	pop hl
	push de
	jp (hl)
	
	; Routine provided by Runer112 on Cemetech.org. Thanks!
Div24by24:
	ld hl,IntArg1
	ld e,(hl)
	inc hl
	ld d,(hl)
	inc hl
	ld c,(hl)
	push de
	ld de,IntArg0
	ld a,(de)
	ld l,a
	inc de
	ld a,(de)
	ld h,a
	inc de
	ld a,(de)
	pop de
	ld b,a    ;INPUTS: ahl = dividend cde = divisor
	push hl   ;OUTPUTS: cde = quotient ahl = remainder
	pop ix
	ld l,24
	push hl
	xor a
	ld h,a
	ld l,a
__Div24by24loop:
	add ix,ix
	rl b
	adc hl,hl
	rla
	cp c
	jr c,__Div24by24skip
	jr nz,__Div24by24setbit
	sbc hl,de
	add hl,de
	jr c,__Div24by24skip
__Div24by24setbit:
	sbc hl,de
	sbc a,c
	inc ix
__Div24by24skip:
	ex (sp),hl
	dec l
	ex (sp),hl
	jr nz,__Div24by24loop
	pop de
	ld c,b
	push ix
	pop de
	ret
	
	;.module Add			; ORG IDE does not recognize .module directive :(
	; Adds the two numbers at the top of the hardware stack and leaves their sum at the top of the hardware stack.
Add:
	call FreeIntArg0
	pop bc
	pop hl
	push hl
	ld de,IntArg0
	scf
	ccf
	ld a,(de)
	adc a,(hl)
	ld (hl),a
	inc hl
	inc de
	ld a,(de)
	adc a,(hl)
	ld (hl),a
	inc hl
	inc de
	ld a,(de)
	adc a,(hl)
	ld (hl),a
	inc hl
	inc de
	ld a,(de)
	adc a,(hl)
	ld (hl),a
	push bc
	ret
	
	;.module ShiftRight
	; Shifts the number on top of the stack by b bits to the right bringing in zeroes
ShiftRight:
	pop de
	pop hl
	xor a
	or b
	jr z,_ShiftRightSkip
_ShiftRightLoop:
	inc hl
	inc hl
	inc hl
	srl (hl)
	dec hl
	rr (hl)
	dec hl
	rr (hl)
	dec hl
	rr (hl)
	djnz _ShiftRightLoop
_ShiftRightSkip:
	ex de,hl
	push de
	jp (hl)
	
	;.module ShiftLeft
	; Shifts the number on top of the stack by b bits to the left bringing in zeroes
ShiftLeft:
	pop de
	pop hl
	xor a
	or b
	jr z,_ShiftLeftSkip
_ShiftLeftLoop:
	sla (hl)
	inc hl
	rl (hl)
	inc hl
	rl (hl)
	inc hl
	rl (hl)
	dec hl
	dec hl
	dec hl
	djnz _ShiftLeftLoop
_ShiftLeftSkip:
	ex de,hl
	push de
	jp (hl)
	
	;.module BitAnd
	; Pops two numbers off the top of the stack and pushes the bitwise AND of the two numbers
BitAnd:
	call FreeIntArg0
	pop bc
	pop de
	push de
	ld hl,IntArg0
	ld a,(de)
	and (hl)
	ld (de),a
	inc hl
	inc de
	ld a,(de)
	and (hl)
	ld (de),a
	inc hl
	inc de
	ld a,(de)
	and (hl)
	ld (de),a
	inc hl
	inc de
	ld a,(de)
	and (hl)
	ld (de),a
	push bc
	ret
	
	;.module BitOr
	; Pops two numbers off the top of the stack and pushes the bitwise OR of the two numbers
BitOr:
	call FreeIntArg0
	pop bc
	pop de
	push de
	ld hl,IntArg0
	ld a,(de)
	or (hl)
	ld (de),a
	inc hl
	inc de
	ld a,(de)
	or (hl)
	ld (de),a
	inc hl
	inc de
	ld a,(de)
	or (hl)
	ld (de),a
	inc hl
	inc de
	ld a,(de)
	or (hl)
	ld (de),a
	push bc
	ret
	
	;.module BitXor
	; Pops two numbers off the top of the stack and pushes the bitwise XOR of the two numbers
BitXor:
	call FreeIntArg0
	pop bc
	pop de
	push de
	ld hl,IntArg0
	ld a,(de)
	xor (hl)
	ld (de),a
	inc hl
	inc de
	ld a,(de)
	xor (hl)
	ld (de),a
	inc hl
	inc de
	ld a,(de)
	ld a,(de)
	xor (hl)
	ld (de),a
	inc hl
	inc de
	ld a,(de)
	xor (hl)
	ld (de),a
	push bc
	ret
	
	;.module ListGet
	; Gets the element at the index on the top of the list from the list
	; Pushes that element on to the stack and deallocates the list
ListGet:
	pop bc
	pop de ; The index
	pop hl ; The List
	push de
	push bc
	ld a,(de)
	add a,a
	add a,a
	ld c,a
	ld b,0
	add hl,bc
	inc hl
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	ld a,(hl)
	ld (de),a
	dec hl
	dec hl
	dec hl
	dec hl
	push hl
	call Free ; Free the list
	ret
	
	;.module ListVarGet
	; Gets the element at the index on the top of the stack from the list at hl.
	; Does not deallocate the list at hl. Should only be used on persistent list vars.
ListVarGet:
	pop bc
	pop de
	push bc
	ld a,(de) 
	add a,a
	add a,a
	inc a
	ld c,a
	ld b,0
	add hl,bc
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	ld a,(hl)
	ld (de),a
	dec de
	dec de
	dec de
	pop hl
	push de
	jp (hl)
	
	
	;.module ListSet
	; Sets the element at the index on top of the stack in the list below it to the value below that 
	; Frees all inputs but the list
ListSet:
	pop bc
	pop de ; The index
	pop hl ; The List
	push bc
	push de
	ld a,(de)
	add a,a
	add a,a
	ld c,a
	ld b,0
	ex de,hl ; Dereference hl
	ld a,(de)
	ld l,a
	inc de
	ld a,(de)
	ld h,a
	add hl,bc
	inc hl
	pop de
	push hl
	push de
	call Free ; Free the index
	pop hl
	pop bc
	pop de ; The value to set
	push bc
	push de
	ld a,(de)
	ld (hl),a
	inc hl
	inc de
	ld a,(de)
	ld (hl),a
	inc hl
	inc de
	ld a,(de)
	ld (hl),a
	inc hl
	inc de
	ld a,(de)
	ld (hl),a
	call Free ; Free the index
	ret
	
	;.module Dimension
	; Frees the list on top of the stack and pushes its size
Dimension:
	ld c,4
	call Alloc
	pop de
	pop bc
	pop hl
	push de
	push bc
	ld a,(hl)
	ld (de),a
	inc de
	ld a,$0
	ld (de),a
	inc de
	ld (de),a
	inc de
	ld (de),a
	push hl
	call Free
	ret
	
	;.module Augment
	; Concatenates the two lists at the top of the stack into a new list
Augment:
	pop bc
	pop de ; List1
	pop hl ; List2
	push bc
	ld a,(de)
	add a,(hl)
	ld b,a
	add a,a
	add a,a
	ld c,a
	inc c ; Include size bit
	ld a,b ; Actual dimention
	push hl
	push de
	push af ; a holds concatenated size
	call Alloc
	pop de ; Allocated string
	pop af ; Size
	pop hl ; Str1
	push de
	ld (de),a
	inc de
	push hl
	ld a,(hl) ; List1 size
	add a,a
	add a,a
	ld b,a
_AugmentLoadList1:
	inc hl
	ld a,(hl)
	ld (de),a
	inc de
	djnz _AugmentLoadList1
	pop hl
	push de
	push hl
	call Free ; Free List1
	pop de
	pop bc
	pop hl
	push bc
	push hl
	ld a,(hl) ; List2 size
	add a,a
	add a,a
	ld b,a
_AugmentLoadList2:
	inc hl
	ld a,(hl)
	ld (de),a
	inc de
	djnz _AugmentLoadList2
	call Free ; Free List2
	pop de
	pop hl
	push de
	jp (hl)
	
	;.module Pop
	; Location of list to pop from stored in de
	; Removes the last item from the list and pushes it to the stack. Decreases list size.
Pop:
	ld a,(de)
	dec a
	ld b,a
	add a,a
	add a,a
	ld c,a
	ld a,b
	ld (de),a
	ld b,0
	ex de,hl
	add hl,bc
	inc hl
	push hl
	ld c,4
	call Alloc
	pop de
	pop hl
	pop bc
	push de
	push bc
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	ld a,(hl)
	ld (de),a
	ret
	
	;.module Concat
	; Concatonates the two strings at the top of the stack into a new string
	; Strings preceded by length byte, then string
	; TODO check if the concatenated strings would fit within either of the allocated strings
Concat:
	pop bc
	pop hl ; Str1
	pop de ; Str2
	push bc
	ld a,(de)
	add a,(hl)
	ld c,a
	inc c ; Include size bit
	push hl
	push de
	push af ; a holds concatenated size
	call Alloc
	pop de ; Allocated string
	pop af ; Size
	pop hl ; Str1
	push de
	ld (de),a
	inc de
	push hl
	ld b,(hl) ; Str1 size
_ConcatLoadStr1:
	inc hl
	ld a,(hl)
	ld (de),a
	inc de
	djnz _ConcatLoadStr1
	pop hl
	push de
	push hl
	call Free ; Free Str1
	pop de
	pop bc
	pop hl
	push bc
	push hl
	ld b,(hl) ; Str2 size
_ConcatLoadStr2:
	inc hl
	ld a,(hl)
	ld (de),a
	inc de
	djnz _ConcatLoadStr2
	call Free ; Free Str2
	pop de
	pop hl
	push de
	jp (hl)
	
	;.module SubString
	; Arguments: [top] start, length, string [bottom]
	; Pushes the substring starting at start that is length long.
	; TODO error checking and handling
SubString:
	call FreeIntArg0 ; Start
	call FreeIntArg1 ; Length
	ld a,(IntArg1)
	ld c,a
	inc c
	call Alloc
	pop de ; New string
	pop bc 
	pop hl ; Old string
	push bc
	push de
	push hl
	ld a,(IntArg0)
	ld c,a
	ld b,0
	add hl,bc
	ld a,(IntArg1)
	ld (de),a
	ld b,a
_SubStringLoop:
	inc de
	inc hl
	ld a,(hl)
	ld (de),a
	djnz _SubStringLoop
	call Free
	pop de
	pop hl
	push de
	jp (hl)
	
	;.module Output
	; Frees 2 ints (row and colomn) and a string and displays the string at the coordinates
	; Stack: [top] row, col, string [bottom]
Output:
	res AppAutoScroll,(IY + AppFlags)
	call FreeIntArg0 ; row
	call FreeIntArg1 ; col
	ld hl,IntArg0
	ld a,(hl)
	ld (CurRow),a
	ld hl,IntArg1
	ld a,(hl)
	ld (CurCol),a
	pop de
	pop hl
	push de
	push hl
	ld b,(hl)
_OutputLoop:
	inc hl
	ld a,(hl)
	bcall(_PutC)
	djnz _OutputLoop
	call Free
	ret
	
	;.module Disp
	; Frees and Displays the string at the top of the hardware stack
Disp:
	set AppAutoScroll, (IY + AppFlags)
	ld a,0
	ld (CurCol),a
	pop de
	pop hl
	push de
	push hl
	ld b,(hl)
_DispLoop:
	inc hl
	ld a,(hl)
	bcall(_PutC)
	djnz _DispLoop
	call Free
	bcall(_NewLine)
	ret
	
DispNumCaller:
.dw $00
	;.module DispNum
	; Frees and displays the number at the top of the hardware stack.
DispNum:
	ld de,DispNumCaller
	pop hl
	ld a,l
	ld (de),a
	inc de
	ld a,h
	ld (de),a
	call Num2Str
	call Disp
	ld de,DispNumCaller
	ld a,(de)
	ld l,a
	inc de
	ld a,(de)
	ld h,a
	jp (hl)
	
Num2StrOut:
.dw $00 ; Holds a pointer to allocated string
	;.module Num2Str
	; Converts the integer in IntArg0 to a string and pushes the results to the stack 
	; Maye be a faster way to do this using division and remainders (the usual way) instead of subtraction
Num2Str:
	call FreeIntArg0
	ld c,9
	call Alloc
	pop hl
	ld de,Num2StrOut
	ld a,l
	ld (de),a
	inc de
	ld a,h
	ld (de),a
	ld de,(Num2StrOut)
	ld a,$1 
	ld (de),a ; Always want to display at least 1 character
	inc de
	ld a,'0'
	ld (de),a
	ld de,IntArg0
	ld	hl,Ten_Million			; HL is the base 10 number to subtract
	ld	b,8				; Number of digits needed to check at max
	ld	c,0					; C counts how many subtractions occur before an overflow
_Num2StrNumLoop:
	push bc
	ld	b,2
	scf
	ccf
_Num2StrNumSubLoop:
	ld	a,(de)
	sbc a,(hl)
	ld	(de),a
	inc hl
	inc de
	djnz _Num2StrNumSubLoop
	pop bc
	ld	a,(de)
	sbc a,(hl)				; Last subtraction goes outside of loop to check underflow
	ld	(de),a
	dec de					; Reset DE for next subtraction.
	dec de
	dec hl					; Reset HL for next subtraction. (there may be a more efficient way to subtract 3)
	dec hl
	jr	nc,_Num2StrNumNoUnderflow	; Check for underflow with carry register
	ld a,'0'
	add a,c
	push hl
	push de
	push bc
	ld hl,(Num2StrOut)
	ld b,(hl)
	dec b
	jr nz,_Num2StrSkipDigitCheck
	cp '0'
	jr z,_num2StrSkipLeadingZero
_num2StrSkipDigitCheck:
	inc b
	inc (hl)
_num2StrLoadDigitLoop:
	inc hl
	djnz _num2StrLoadDigitloop
	ld (hl),a
_num2StrSkipLeadingZero:
	pop bc
	pop de
	pop hl
	ld	c,0
	push bc
	ld	b,3
_Num2StrNumAddLoop:
	ld	a,(de)
	adc a,(hl)
	ld	(de),a
	inc de
	inc hl
	djnz	_Num2StrNumAddLoop
	dec de
	dec de
	dec de
	pop bc
	dec b
	jr	z,_Num2StrNumEnd
	jr	_Num2StrNumSkipUnderflow
_Num2StrNumNoUnderflow:
	inc c
_Num2StrNumSkipUnderflow:
	jr	_Num2StrNumLoop
_Num2StrNumEnd:
	ld hl,(Num2StrOut)
	ld a,(hl)
	dec a
	jr z,_Num2StrSkipDec ; Don't decrement if length is already 1
	dec (hl)
_Num2StrSkipDec:
	ex de,hl
	pop hl
	push de
	jp (hl)
	
	;.module LoadIntVar 
	; Location of Int Var stored in de
LoadIntVar:
	push de
	ld c,4
	call Alloc
	pop de ; Allocated memory
	pop hl ; Location to load from
	push de
	ld a,(hl)
	ld (de),a
	inc de
	inc hl
	ld a,(hl)
	ld (de),a
	inc de
	inc hl
	ld a,(hl)
	ld (de),a
	inc de
	inc hl
	ld a,(hl)
	ld (de),a
	pop de
	pop hl
	push de
	jp (hl)
	
	;.module LoadStrVar
	; Locationod StrVar stored in de
LoadStrVar:
	ld a,(de)
	ld l,a
	inc de
	ld a,(de)
	ld h,a
	ld c,(hl)
	inc c
	push hl
	call Alloc
	pop de ; New string
	pop hl ; Str var
	push de
	ld b,(hl)
	inc b
_LoadStrVarLoop:
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	djnz _LoadStrVarLoop
	pop de
	pop hl
	push de
	jp (hl)
	
AllocPrev:
.dw $0000
	;.module Alloc
	; allocates c bytes on the heap and returns a pointer to those bytes.
	; Does not coalesce. Max size is 256 (1 byte).
	; Because no coalesce, will not split chunks. 
	; Possible to  ask for 3 bytes and get a 256 byte chunk.
	; struct Block {
	; 		Next*		2 byte
	; 		Size		1 byte
	;		Payload	x byte
	; }
	; 1. Find a block
	; 2. Change the previous block to point where its next block points
	; 3. Set the size of the data in the structure
	; 4. Push a pointer to the block and return
Alloc:
	ld de,AllocPrev
	ld hl,FreePtr
	ld a,l
	ld (de),a
	inc de
	ld a,h
	ld (de),a
	ld b,0
	ld hl,(FreePtr)
_AllocFindMemLoop:
	ld a,(hl)
	inc hl
	or (hl) ; check if hl is 00.
	jr z,_AllocSplitEnd
	inc hl
	ld a,(hl) ; load capacity into a
	cp c
	jr z,_AllocNoSplit
	jr nc,_AllocSplit
	dec hl
	dec hl
	ld de,AllocPrev ; Save the location of the previous block
	ld a,l
	ld (de),a
	inc de
	ld a,h
	ld (de),a
	ld d,h
	ld e,l ; Make hl point to the next block in the linked list
	ld a,(de)
	ld l,a
	inc de
	ld a,(de)
	ld h,a
	jr _AllocFindMemLoop
_AllocSplit:
	; TODO write this to actually split once coalescing works. 
	; Tradeoff between internal and external fragmentation
	ld c,a
_AllocNoSplit:
	; Push and change the previous block to point to this block's next
	inc hl
	push hl
	ld de,(AllocPrev)
	dec hl ; hl points to size
	ld (hl),c
	dec hl
	dec hl ; hl points to next*
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	ld a,(hl)
	ld (de),a
	pop de
	pop hl
	push de
	jp (hl) ; Return
_AllocSplitEnd:
	inc hl ; hl points to the size
	ld (hl),c
	inc hl ; hl points to the payload
	push hl
	ld d,0
	ld e,c
	add hl,de ; Change hl to point to the new start of blank memory
	ld de,(AllocPrev)
	ld a,l ; Load in little endian order
	ld (de),a
	inc de
	ld a,h
	ld (de),a
	ld (hl),0 ; Set the next pointer of the end bank to 00
	inc hl
	ld (hl),0
	pop de
	pop hl
	push de
	jp (hl) ; Return
	
	;.module Free
	; Frees the memory pointed to at the top of the stack
	; Just a linked list insertion. Later, must coalesce (needs prev pointer).
	; TODO Coalesce!
Free:
	pop de
	pop hl
	push de
	dec hl
	dec hl
	dec hl ; hl points to next
	ld de,(FreePtr) ; Load current beginning address into the freed block's next
	ld (hl),e
	inc hl
	ld (hl),d ; Load in little endian order
	ld de,FreePtr ; Make the freed block the beginning of the free list
	dec hl ; hl points to beginning of block
	ld a,l
	ld (de),a
	inc de
	ld a,h
	ld (de),a
	ret 
	
Billion:
.db $CA, $9A, $3B
Hundred_Million:
.db $E1, $F5, $05
Ten_Million:
.db $80, $96, $98
Million:
.db $40, $42, $0F
Hundred_Thousand:
.db $A0, $86, $01
Ten_Thousand:
.db $10, $27, $00
Thousand:
.db $E8, $03, $00
Hundred:
.db $64, $00, $00
Ten:
.db $0A, $00, $00
One:
.db $01, $00, $00
	
IntArg0:
.db $00, $00, $00, $00
IntArg1:
.db $00, $00, $00, $00
	
	; Table of IntVars (A-Z)
IntVar:
.ds $58, $0
StrVar:
.ds $14, $0
ListVar:
.ds $0B, $0
	
FuncTemp:
.dw $00
FuncRet:
.dw $00
InitStack:
.dw $00
FreePtr:
.dw Heap
	
Heap:
.dw $00
.ds $3B0, $0 ; 1024 bytes for the heap otherwise OS will put important data there
