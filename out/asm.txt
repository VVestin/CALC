#include "ti83plus.inc"
#define progStart $9D95
#define TEMP_SIZE $100
.org progStart-2
.db $BB,$6D
	bcall(_ClrLCDFull)
	bcall(_HomeUp)
	ld hl,(TempPtr)
	ld (hl),$01
	inc hl
	ld (hl),$00
	inc hl
	ld (hl),$00
	inc hl
	ld (hl),$00
	dec hl
	dec hl
	dec hl
	push hl
	ld de,(TempPtr)
	ld h,0
	ld l,4
	add hl,de
	ld (TempPtr),hl
	ld hl,(TempPtr)
	ld (hl),$02
	inc hl
	ld (hl),$00
	inc hl
	ld (hl),$00
	inc hl
	ld (hl),$00
	dec hl
	dec hl
	dec hl
	push hl
	ld de,(TempPtr)
	ld h,0
	ld l,4
	add hl,de
	ld (TempPtr),hl
	ld hl,(TempPtr)
	ld (hl),$04
	inc hl
	ld (hl),$00
	inc hl
	ld (hl),$00
	inc hl
	ld (hl),$00
	dec hl
	dec hl
	dec hl
	push hl
	ld de,(TempPtr)
	ld h,0
	ld l,4
	add hl,de
	ld (TempPtr),hl
	ld hl,(TempPtr)
	ld (hl),$1E
	inc hl
	ld (hl),$00
	inc hl
	ld (hl),$00
	inc hl
	ld (hl),$00
	dec hl
	dec hl
	dec hl
	push hl
	ld de,(TempPtr)
	ld h,0
	ld l,4
	add hl,de
	ld (TempPtr),hl
	ld hl,(TempPtr)
	ld (hl),$03
	inc hl
	ld (hl),$00
	inc hl
	ld (hl),$00
	inc hl
	ld (hl),$00
	dec hl
	dec hl
	dec hl
	push hl
	ld de,(TempPtr)
	ld h,0
	ld l,4
	add hl,de
	ld (TempPtr),hl
	call Mult
	call Negate
	call Add
	ret
	
	;.module Negate
	; Negates the 4 byte integer at the top of the stack
Negate:
	pop bc
	pop hl
	push hl
	push bc
	ld a,(hl)
	ld b,4
	scf
	ccf
_NegateCPLLoop:
	ld a,0
	sbc a,(hl)
	ld (hl),a
	inc hl
	djnz _NegateCPLLoop
	ret
	
	; .module Compare
	; Compares two numbers at the top of the stack
	; Does a greater than if carry is set, otherwise a less than
Compare:
	pop bc
	pop hl
	pop de
	push bc
	jr c, _CompareGreater
	ex de,hl
_CompareGreater:
	ld b,4
_CompareLoop:
	ld a,(de)
	cp (hl)
	jr c,_CompareTrue
	jr nz,_CompareFalse
	djnz _CompareLoop
_CompareFalse:
	ld b,0
	jr _EqualsPushResult
_CompareTrue:
	ld b,1
	jr _EqualsPushResult
	
	; .module CompareEqual (<= and >=)
	; Compares two numbers at the top of the stack
	; Does a greater than if carry is set, otherwise a less than
CompareEqual:
	pop bc
	pop hl
	pop de
	push bc
	jr c, _CompareEqualGreater
	ex de,hl
_CompareEqualGreater:
	ld b,4
_CompareEqualLoop:
	ld a,(de)
	cp (hl)
	jr c,_CompareEqualTrue
	jr nz,_CompareEqualFalse
	djnz _CompareEqualLoop
_CompareEqualTrue:
	ld b,1
	jr _EqualsPushResult
_CompareEqualFalse:
	ld b,0
	jr _EqualsPushResult
	
	;.module Equals
	; Compares two numbers at the top of the stack for equality, leaving the stack with a 1 if equal
Equals:
	pop bc
	pop hl
	pop de
	push bc
	ld b,3
_EqualsLoop:
	ld a,(de)
	cp (hl)
	jr nz,_EqualsNotEqual
	inc hl
	inc de
	djnz _EqualsLoop
	ld b,1
	jr _EqualsPushResult
_EqualsNotEqual:
	ld b,0
_EqualsPushResult:
	ld hl,(TempPtr)
	ld (hl),b
	ld b,3
_EqualsPushZeroes:
	inc hl
	ld (hl),0
	djnz _EqualsPushZeroes
	inc hl
	ld (TempPtr),hl
	dec hl
	dec hl
	dec hl
	dec hl
	pop de
	ex de,hl
	push de
	jp (hl)
	
	; .module Mult
	; Multiplies the two numbers at the top of the stack and leaves the stack with only the result
Mult:
	pop bc
	pop hl
	pop de
	push bc
	
	ld b,32
_MultLoop:
	push bc
	ld b,3
	ex de,hl
	inc hl
	inc hl
	inc hl
	srl (hl)
_MultShiftDELoop:
	dec hl
	rr (hl)
	djnz _MultShiftDELoop
	ex de,hl
	jr nc,_MultSkipAdd
	push de
	ld de,_MultResult
	ld b,4
	ccf ; Resets carry because carry should always be true here
_MultAddLoop:
	ld a,(de)
	adc a,(hl)
	ld (de),a
	inc hl
	inc de
	djnz _MultAddLoop
	dec hl
	dec hl
	dec hl
	dec hl
	pop de
_MultSkipAdd:
	ld b,3
	sla (hl)
_MultShiftHLLoop:
	inc hl
	rl (hl)
	djnz _MultShiftHLLoop
	dec hl
	dec hl
	dec hl
	pop bc
	djnz _MultLoop
	; Store the value in _MultResult in temp and push to stack 
	ld hl,_MultResult
	ld de,(TempPtr)
	ld b,4
_MultPushLoop:
	ld a,(hl)
	ld (de),a
	inc hl
	inc de
	djnz _MultPushLoop
	dec de
	dec de
	dec de
	dec de
	pop hl
	push de
	push hl
	ld de,(TempPtr)
	ld h,0
	ld l,4
	add hl,de
	ld (TempPtr),hl
	ret
_MultResult:
.db $00, $00, $00, $00
	
	
	;.module Add			; ORG IDE does not recognize .module directive :(
	; Adds the two numbers at the top of the hardware stack and leaves their sum at the top of the hardware stack.
Add:
	pop		bc
	pop		hl
	pop		de
	push		bc
	ld			b,4
	scf
	ccf
_AddLoop:
	ld			a,(de)
	adc		a,(hl)
	ld			(de),a
	inc		hl
	inc		de
	djnz _AddLoop
	dec		de
	dec		de
	dec		de
	dec		de
	pop		hl
	push		de
	jp			(hl)
	
	; .module Disp
	; Displays the number at the top of the hardware stack.
	; Destroys pretty much every register and flag
	; Destroys the inputted number
	; TODO stop displaying leading zeroes. 
	; TODO right justify
	; TODO move number logic to a num2str function and make Disp function display strings
Disp:
	ld			hl,Billion			; HL is the base 10 number to subtract
	pop		bc
	pop		de					; DE is the number to display
	push		bc
	ld			b,10				; Number of digits needed to check at max
	ld			c,0					; C counts how many subtractions occur before an overflow
_DispLoop:
	push		bc
	ld			b,3
	scf
	ccf
_DispSubLoop:
	ld			a,(de)
	sbc		a,(hl)
	ld			(de),a
	inc		hl
	inc		de
	djnz		_DispSubLoop
	pop		bc
	ld			a,(de)
	sbc		a,(hl)				; Last subtraction goes outside of loop to check underflow
	ld			(de),a
	dec		de					; Reset DE for next subtraction.
	dec		de
	dec		de
	dec		hl					; Reset HL for next subtraction. (there may be a more efficient way to subtract 3)
	dec		hl
	dec		hl
	jr			nc,_DispNoUnderflow	; Check for underflow with carry register
	ld			a,'0'
	add		a,c
	bcall(_PutC)
	ld			c,0
	push		bc
	ld			b,4
_DispAddLoop:
	ld			a,(de)
	adc		a,(hl)
	ld			(de),a
	inc		de
	inc		hl
	djnz	_DispAddLoop
	dec		de
	dec		de
	dec		de
	dec		de
	pop		bc
	dec		b
	jr			z,_DispEnd
	jr			_DispSkipUnderflow
_DispNoUnderflow:
	inc		c
_DispSkipUnderflow:
	jr			_DispLoop
_DispEnd:
	bcall(_NewLine)
	ret
	
	; .module LoadIntVar 
	; Location of Int Var stored in de
LoadIntVar:
	ld			hl,(TempPtr)
	ld			b,4
_LoadIntVar:
	ld			a,(de)
	ld			(hl),a
	inc		hl
	inc		de
	djnz		_LoadIntVar
	dec		hl
	dec		hl
	dec		hl
	dec		hl
	pop		bc
	push		hl
	push		bc
	ld			de,(TempPtr)
	ld			h,0
	ld			l,4
	add		hl,de
	ld			(TempPtr),hl
	ret
	
Billion:
.db $00, $CA, $9A, $3B
Hundred_Million:
.db $00, $E1, $F5, $05
Ten_Million:
.db $80, $96, $98, $00
Million:
.db $40, $42, $0F, $00
Hundred_Thousand:
.db $A0, $86, $01, $00
Ten_Thousand:
.db $10, $27, $00, $00
Thousand:
.db $E8, $03, $00, $00
Hundred:
.db $64, $00, $00, $00
Ten:
.db $0A, $00, $00, $00
One:
.db $01, $00, $00, $00
	
IntVar:
.ds $68, $0
TempPtr:
.dw Temp
.db $00
Temp:
.ds TEMP_SIZE, $0
